from fastapi import APIRouter, HTTPException, Depends, Request, Body
from app.services.donor_service import (
create_donation_in_db,
get_donation_by_id,
process_fake_payment_in_db,
get_donations_by_user,
get_recent_donations_in_db,
get_donation_statistics_in_db,
get_drop_off_locations_in_db,
)

from app.utils.jwt_handler import jwt_required
from typing import List

router = APIRouter()

@router.post("/donations")
async def create_donation(payload: dict = Depends(jwt_required), donation_data: dict =Body(...)):
    """
    API Endpoint: Allow only donors to make a donation.
    """

    if payload.get("role") != "donor":
        raise HTTPException(status_code=403, detail="Only donors can make donations")
    
     # Required key in the body
    required_key = ["foodbank_id","amount"]

    # Start validation those keys
    for key in required_key:
        if not donation_data.get(key):
            raise HTTPException(
                status_code=400, detail=f"{key} is required and cannot be empty"
            )
        
    if donation_data["amount"] <= 0:
        raise HTTPException(status_code=400, detail="Donation amount must be greater than zero")


    donation = await create_donation_in_db(donor_id = payload.get("sub"), donation_data = donation_data)

    return {
        "status": "success",
        "message": "Donation recorded successfully",
        "donation": donation
    }

@router.post("/create-fake-payment-intent")
async def create_fake_payment_intent(
    payload: dict = Depends(jwt_required),
    payment_data: dict = Body(...)
):
    """
    Simulate a payment intent creation without real money.
    Generates a fake transaction ID and client secret.
    """
    if payload.get("role") != "donor":
        raise HTTPException(status_code=403, detail="Only donors can process payments")

    amount = payment_data.get("amount")
    if not amount or amount <= 0:
        raise HTTPException(status_code=400, detail="Valid donation amount is required")

    # Generate fake payment details
    import uuid
    fake_transaction_id = "TXN" + str(uuid.uuid4().hex[:10]).upper()
    fake_client_secret = "fake_secret_" + str(uuid.uuid4().hex)

    return {
        "status": "success",
        "clientSecret": fake_client_secret,
        "transactionId": fake_transaction_id
    }

@router.post("/donations/{donation_id}/payment")
async def process_simulated_payment(
    donation_id: str,
    payload: dict = Depends(jwt_required),
    payment_data: dict = Body(...)
):
    """
    Process a simulated payment for a donation.
    Accepts a transaction ID (generated by our fake payment intent) and updates the donation record.
    Only minimal transaction information is stored (User ID and Transaction ID).
    """
    if payload.get("role") != "donor":
        raise HTTPException(status_code=403, detail="Only donors can process payment for donations")
    
    transaction_id = payment_data.get("transaction_id")
    if not transaction_id:
        raise HTTPException(status_code=400, detail="transaction_id is required for payment")
    
    # Process simulated payment (update donation record with fake transaction ID)
    updated_donation = await process_fake_payment_in_db(donation_id, transaction_id)
    return {"status": "success", "message": "Payment processed successfully", "donation": updated_donation}

@router.get("/donations/{donation_id}")
async def get_donation(
    donation_id: str,
    payload: dict = Depends(jwt_required)
):
    """
    Retrieve a specific donation by its ID.
    """
    # Allow donor or foodbank admin to view donation details
    if payload.get("role") not in ["donor", "foodbank"]:
        raise HTTPException(status_code=403, detail="Not authorized to view donation details")
    
    donation = await get_donation_by_id(donation_id)
    if not donation:
        raise HTTPException(status_code=404, detail="Donation not found")
    
    return {"status": "success", "donation": donation}

@router.get("/donations/user")
async def get_donations_for_user(payload: dict = Depends(jwt_required)):
    """
    Retrieve all donations made by the logged-in donor.
    """
    if payload.get("role") != "donor":
        raise HTTPException(status_code=403, detail="Only donors can view their donations")
    
    donations = await get_donations_by_user(donor_id=payload.get("sub"))
    return {"status": "success", "donations": donations}

@router.get("/donations/recent")
async def get_recent_donations(payload: dict = Depends(jwt_required)):
    """
    Retrieve recent donation updates for the donation tracker.
    """
    # This endpoint can be available to both donors and foodbank admins
    if payload.get("role") not in ["donor", "foodbank"]:
        raise HTTPException(status_code=403, detail="Not authorized to view recent donations")
    
    recent_donations = await get_recent_donations_in_db()
    return {"status": "success", "recent_donations": recent_donations}

@router.get("/donations/statistics")
async def get_donation_statistics(payload: dict = Depends(jwt_required)):
    """
    Retrieve aggregated donation statistics.
    """
    # Available for donors and foodbank admins
    if payload.get("role") not in ["donor", "foodbank"]:
        raise HTTPException(status_code=403, detail="Not authorized to view donation statistics")
    
    stats = await get_donation_statistics_in_db()
    return {"status": "success", "statistics": stats}

@router.get("/dropoff-locations")
async def get_drop_off_locations(payload: dict = Depends(jwt_required)):
    """
    Retrieve a list of drop-off locations for donors.
    """
    # Available for any authenticated user (or you can limit to donors if required)
    locations = await get_drop_off_locations_in_db()
    return {"status": "success", "dropoff_locations": locations}